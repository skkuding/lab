## Argo CD configuration
## Ref: https://github.com/argoproj/argo-cd

## Globally shared configuration
global:
  domain: argocd.lab.skkuding.dev
  revisionHistoryLimit: 3

  logging:
    format: json
    level: info

## Argo Configs
configs:
  # General Argo CD configuration. Any values you put under `.configs.cm` are passed to argocd-cm ConfigMap.
  ## Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cm.yaml
  cm:
    # Dex configuration
    dex.config: |
      connectors:
        - type: github
          id: github
          name: GitHub
          config:
            clientID: aabbccddeeff00112233
            clientSecret: $dex.github.clientSecret # Alternatively $<some_K8S_secret>:dex.github.clientSecret
            orgs:
            - name: your-github-org

  # -- Provide one or multiple [external cluster credentials]
  # @default -- `{}` (See [values.yaml])
  ## Ref:
  ## - https://argo-cd.readthedocs.io/en/stable/operator-manual/declarative-setup/#clusters
  ## - https://argo-cd.readthedocs.io/en/stable/operator-manual/security/#external-cluster-credentials
  ## - https://argo-cd.readthedocs.io/en/stable/user-guide/projects/#project-scoped-repositories-and-clusters
  clusterCredentials: {}
    # mycluster:
    #   server: https://mycluster.example.com
    #   labels: {}
    #   annotations: {}
    #   config:
    #     bearerToken: "<authentication token>"
    #     tlsClientConfig:
    #       insecure: false
    #       caData: "<base64 encoded certificate>"

  # -- Repositories list to be used by applications
  ## Creates a secret for each key/value specified below to create repositories
  ## Note: the last example in the list would use a repository credential template, configured under "configs.credentialTemplates".
  repositories:
    lab:
      url: https://github.com/skkuding/lab
      name: lab
      type: git

  # Argo CD sensitive data
  # Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/user-management/#sensitive-data-and-sso-client-secrets
  secret:
    # -- Create the argocd-secret
    createSecret: true

    # -- Shared secret for authenticating GitHub webhook events
    githubSecret: ""

    # -- Bcrypt hashed admin password
    ## Argo expects the password in the secret to be bcrypt hashed. You can create this hash with
    ## `htpasswd -nbBC 10 "" $ARGO_PWD | tr -d ':\n' | sed 's/$2y/$2a/'`
    argocdServerAdminPassword: ""
    # -- Admin password modification time. Eg. `"2006-01-02T15:04:05Z"`
    # @default -- `""` (defaults to current time)
    argocdServerAdminPasswordMtime: ""

# -- Array of extra K8s manifests to deploy
## Note: Supports use of custom Helm templates
extraObjects:
  - apiVersion: bitnami.com/v1alpha1
    kind: SealedSecret
    metadata:
      name: dex-github-secret
      namespace: argocd
    spec:
      encryptedData:
        clientID: # TODO
        clientSecret: # TODO
      template:
        metadata:
          name: dex-github-secret
          namespace: argocd
        type: Opaque

## Application controller
controller:
  name: application-controller
  replicas: 1

  metrics:
    enabled: true
    serviceMonitor:
      enabled: true

## Dex
dex:
  enabled: true
  name: dex-server
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true

## Server
server:
  name: server
  replicas: 1

  service:
    servicePortHttps: 80
    servicePortHttp: 80

  ## Server metrics service configuration
  metrics:
    # -- Deploy metrics service
    enabled: true
    serviceMonitor:
      enabled: true
      selector:
        prometheus: kube-prometheus

  # Argo CD server ingress configuration
  ingress:
    enabled: true
    annotations:
      cert-manager.io/cluster-issuer: letsencrypt-dns01
      traefik.ingress.kubernetes.io/redirect-entry-point: https
    ingressClassName: traefik
    hostname: argocd.lab.skkuding.dev
    tls: true
    certificateName: argocd-server-tls
    servicePort: 80
  
  extraArgs:
    - --insecure

## Repo Server
repoServer:
  name: repo-server
  replicas: 1
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true
      selector:
        prometheus: kube-prometheus

## ApplicationSet controller
applicationSet:
  name: applicationset-controller
  replicas: 1
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true
      selector:
        prometheus: kube-prometheus

## Notifications controller
notifications:
  enabled: true
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true
      selector:
        prometheus: kube-prometheus

  service.github: |
    appID: $github-app-id
    installationID: $github-installation-id
    privateKey: $github-private-key

  # -- The notification template is used to generate the notification content
  ## For more information: https://argo-cd.readthedocs.io/en/stable/operator-manual/notifications/templates/
  templates:
    template.github-running: |
      message: 'Syncing {{ .app.metadata.name }}'
      github:
        status:
          state: pending
          label: "Argo CD / {{ .app.metadata.annotations.appName }}"
          targetURL: "{{ .context.argocdUrl }}/applications/{{ .app.metadata.name }}?operation=true"

    template.github-succeed: |
      message: 'Successfully synced {{ .app.metadata.name }}'
      github:
        status:
          state: success
          label: "Argo CD / {{ .app.metadata.annotations.appName }}"
          targetURL: "{{ .context.argocdUrl }}/applications/{{ .app.metadata.name }}?operation=true"
        pullRequestComment:
          content: |
            ✅ **Syncing Preview App Succeeded**

            **Application:** `{{ .app.metadata.annotations.appName }}`
            **Revision:** `{{ .app.status.sync.revision }}`
            **Health Status:** {{ .app.status.health.status }}

            [Open Preview]({{ .app.metadata.annotations.previewURL }}) | [View in Argo CD]({{ .context.argocdUrl }}/applications/{{ .app.metadata.name }})

    template.github-failed: |
      message: 'Failed to sync {{ .app.metadata.name }}'
      github:
        status:
          state: failure
          label: "Argo CD / {{ .app.metadata.annotations.appName }}"
          targetURL: "{{ .context.argocdUrl }}/applications/{{ .app.metadata.name }}?operation=true"
        pullRequestComment:
          content: |
            ❗ **Syncing Preview App Failed**

            **Application:** `{{ .app.metadata.annotations.appName }}`
            **Revision:** `{{ .app.status.sync.revision }}`
            **Health Status:** {{ .app.status.health.status }}

            [Open Preview]({{ .app.metadata.annotations.previewURL }}) | [View in Argo CD]({{ .context.argocdUrl }}/applications/{{ .app.metadata.name }})


  # -- The trigger defines the condition when the notification should be sent
  ## For more information: https://argo-cd.readthedocs.io/en/stable/operator-manual/notifications/triggers/
  triggers:
    trigger.on-sync-failed: |
      - when: app.status.sync.status != 'Synced'
        oncePer: app.status.sync.revision
        send: [github-failed]

    trigger.on-sync-running: |
      - when: app.status.sync.status == 'Syncing'
        oncePer: app.status.sync.revision
        send: [github-running]

    trigger.on-sync-succeeded: |
      - when: app.status.sync.status == 'Synced' and app.status.health.status == 'Progressing'
        oncePer: app.status.operationState.syncResult.revision
        send: [github-running]
      - when: app.status.sync.status == 'Synced' and app.status.health.status == 'Healthy'
        oncePer: app.status.operationState.syncResult.revision
        send: [github-succeed]
      - when: app.status.sync.status == 'Synced' and app.status.health.status == 'Degraded'
        oncePer: app.status.operationState.syncResult.revision
        send: [github-failed]